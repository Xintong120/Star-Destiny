# 项目架构
数据层：
FunctionalAstrolabe类：负责基础命盘数据管理
HoroscopeCalculator类：专门处理运限计算逻辑

服务层：
PalaceNameService：处理宫位名称
TimePeriodCalculator：处理时间周期计算
HoroscopeAdapter：格式化运限数据，实现缓存机制

状态管理层：
horoscopeStore：使用Pinia集中管理运限状态
useHoroscope composable：封装可复用的状态逻辑

视图层：
ZiWeiHoroscope.vue：命盘UI组件，负责展示和用户交互

# 项目重构记录

## 2025.07.09

### 新增 点击星耀显示详情信息功能

本次更新实现了核心的交互功能：用户点击命盘中的任意一颗星耀，系统会以通知（Notification）的形式，从左上角弹出该星耀的详细解读信息。该功能的实现历经了从初步实现到数据溯源、代码重构、配置修复等多个阶段，显著提升了应用的数据驱动能力和代码质量。

#### 第一阶段：模态框（Modal）初步实现

1.  **添加点击事件**：在 `ZiWeiPalaceDisplay.vue` 组件中，为所有星耀名称（主星、辅星、杂曜等）的 `<span>` 元素绑定了 `@click.stop` 事件，并统一调用 `showStarInfo` 函数。
2.  **创建模态框组件**：由于需要弹窗显示，新建了 `components/StarInfoModal.vue` 组件，负责展示星耀信息，并包含关闭模态框的基础逻辑。
3.  **组件联动**：在父组件 `ZiWeiPalaceDisplay.vue` 中，通过 `ref` 变量（如 `selectedStar`, `isModalVisible`）来控制模态框的显示状态和传递被点击的星耀对象。

#### 第二阶段：数据溯源与核心重构

1.  **发现数据瓶颈**：我们迅速发现，传递给弹窗的 `star` 对象只包含名称、亮度等基础信息，缺少详细的性格、含义等描述。
2.  **确立唯一标识符（Key）**: 为了从数据文件中动态查找星耀的详细信息，我们必须为每颗星耀确立一个稳定、不随语言变化的唯一标识符（例如，紫微星的 `key` 为 `ziweiMaj`）。
3.  **数据结构重构**:
    *   在 `src/data/types/star.ts` 的 `Star` 类型定义中，增加了 `key: string;` 属性。
    *   同步更新了 `src/star/FunctionalStar.ts` 中的类定义与接口，为其添加了 `key` 属性。
    *   逐一修改了所有创建星耀实例的文件（如 `majorStar.ts`, `minorStar.ts` 等），在 `new FunctionalStar(...)` 的构造函数中，将星耀的唯一 `key` 作为参数传入。
4.  **创建数据源**: 重构完成后，`star` 对象上终于携带了 `key`。我们据此在 `src/data/star-info/` 目录下创建了 `ziweiMaj.json` 等数据文件，存放对应星耀的详细描述。
5.  **实现动态数据加载**: 更新了 `StarInfoModal.vue`，利用 `watch` 监听传入的 `star` 对象。一旦对象有效，就使用其 `key` 属性，通过动态 `import()` 异步加载对应的 JSON 文件，并将获取到的数据显示在模态框中。

#### 第三阶段：样式优化与逻辑提取

1.  **从模态框到通知**: 根据用户需求，决定将弹窗样式从模态框改为 Element Plus 的通知（Notification）组件，并显示在屏幕左上角。
2.  **替换实现方式**:
    *   修改 `ZiWeiPalaceDisplay.vue`，移除了所有与 `StarInfoModal` 相关的代码。
    *   将 `showStarInfo` 函数重写为 `async` 函数，在其中直接完成**异步加载数据**和**调用 `ElNotification`** 两个步骤。
    *   删除了不再需要的 `StarInfoModal.vue` 文件。
3.  **逻辑提取与封装**:
    *   为了提高代码的复用性和整洁性，我们将显示通知的完整逻辑提取到了一个新的工具文件中：`src/utils/starInfo.ts`。
    *   该文件导出一个 `showStarNotification` 函数，封装了所有实现细节。
    *   `ZiWeiPalaceDisplay.vue` 的代码因此变得极为简洁，只需导入并调用该函数即可。

#### 第四阶段：修复模块导入路径问题

在逻辑提取后，遇到了 Vite 和编辑器均无法正确解析模块导入路径的棘手问题。

1.  **问题表现**: 无论是相对路径 (`../utils/starInfo.ts`)、绝对路径 (`/src/utils/starInfo`) 还是路径别名 (`@/utils/starInfo`)，Vite 在运行时均抛出 `Failed to resolve import` 错误。
2.  **定位问题根源**: 经过排查，最终确定问题源于项目的**配置缺失**：
    *   **编辑器层面**: 缺少 `jsconfig.json` 或 `tsconfig.json` 文件来定义路径别名（`@`），导致 Linter 无法识别。
    *   **Vite 层面**: 项目的 `vite.config.js` 文件中没有配置 `resolve.alias`，导致 Vite 在构建和运行时无法解析 `@` 别名。
3.  **最终解决方案**:
    *   首先，创建了一个 `jsconfig.json` 文件，并配置了 `paths`，解决了编辑器层面的路径解析问题。
    *   接着，修改了 `vite.config.js` 文件，为其添加了 `resolve.alias` 配置，解决了 Vite 的运行时问题。
    *   最后，将 `ZiWeiPalaceDisplay.vue` 中的导入路径统一为 `@/utils/starInfo`，至此，路径问题被彻底解决。

通过以上步骤，我们不仅成功实现了功能，还在过程中对项目的数据结构、代码组织和工程化配置进行了全面的优化，为后续开发打下了坚实的基础。

## 2025.07.08

### 修复 ZiWeiPage 无法直接触发排盘抽屉的问题

修复了在无命盘数据的紫微斗数结果页 (`/ziwei`) 时，点击顶部导航栏的"排盘"按钮无法像在首页一样直接弹出抽屉表单的问题。

#### 问题分析

1.  **用户流程中断**：当用户直接访问 `/ziwei` 页面但没有命盘数据时，系统会提示用户去首页输入。此时用户点击导航栏的"排盘"按钮，期望能立即输入信息，但抽屉并未出现，因为该页面组件树中缺少表单抽屉实例。
2.  **组件缺失**: `ZiWeiPage.vue` 组件中并未包含 `<ZiWeiForm />` 子组件。尽管导航栏的"排盘"按钮正确地通过 `drawerStore` 将全局的 `isDrawerOpen` 状态设为了 `true`，但由于页面上没有监听这个状态的抽屉组件，因此没有任何响应。

#### 解决方案

本次修复遵循了与 `HomePage.vue` 完全一致的设计模式，将表单抽屉添加到了结果页面中：

1.  **引入表单组件**: 在 `components/ZiWeiPage.vue` 的 `<script setup>` 部分，导入了 `ZiWeiForm.vue` 组件。
2.  **添加组件到模板**: 在 `ZiWeiPage.vue` 的模板中，直接添加了 `<ZiWeiForm />` 标签。

由于 `ZiWeiForm` 自身已经通过 `drawerStore` 实现了对全局状态的监听，因此只需在页面中简单地实例化该组件，即可使其响应导航栏的打开指令。

## 2025.07.07

### 核心排盘流程重构与状态管理优化

本次更新对核心的"排盘"用户流程进行了彻底重构，解决了因页面跳转导致的数据丢失问题，并修复了因此次重构引入的模块路径解析错误。

#### 1. 排盘流程重构

*   **目标**: 将原有的 "点击按钮 -> 跳转到新页面填写表单" 的流程，优化为 "点击按钮 -> 在当前页弹出抽屉表单 -> 提交表单后跳转到结果页"。
*   **实现**:
    *   **改造 `HomePage.vue`**: "开始分析"按钮的点击事件不再是路由跳转，而是调用 `drawerStore` 中的 `openDrawer` 方法，在当前页拉起表单抽屉。
    *   **改造 `ZiWeiForm.vue`**: 在其表单提交方法 `submitForm` 中，增加了路由跳转逻辑 (`router.push('/ziwei')`)，确保在命盘数据生成后才进行页面跳转。

#### 2. 命盘数据跨页面传递

*   **问题**: 按照新流程，命盘数据在 `HomePage` 中生成，但当路由跳转到 `/ziwei` 页面后，这个在之前页面组件中生成的数据会丢失，导致结果页无法渲染命盘。
*   **解决方案：引入 `astrolabeStore`**:
    *   **创建 Pinia Store**: 新建了 `src/stores/astrolabeStore.ts`，这是一个专门用于存储命盘 (`astrolabe`) 对象和用户姓名 (`personName`) 的全局状态管理中心。
    *   **数据存入 Store**: 修改 `ZiWeiForm.vue`，在生成命盘后，不再将其存入本地变量，而是调用 `astrolabeStore.setAstrolabe()` 方法，将其存入全局 Store。
    *   **创建结果页**: 新建了 `components/ZiWeiPage.vue` 组件，作为 `/ziwei` 路由的目标页面。
    *   **从 Store 读取数据**: `ZiWeiPage.vue` 组件在挂载时，会从 `astrolabeStore` 中读取命盘数据，并将其传递给 `ZiWeiGrid` 组件进行渲染。

#### 3. 模块导入路径修复

*   **问题**: 上述重构完成后，Vite 报出 "Failed to resolve import" 错误。
*   **原因**: 在 `src/router/index.js` 中，错误地使用了 `../components/` 相对路径来导入组件。从 `src/router/` 出发，正确的路径需要上溯两层，应为 `../../components/`。类似的路径错误也存在于 `ZiWeiPage.vue` 对 Store 的导入中。
*   **修复**:
    *   修正了 `src/router/index.js` 中对 `HomePage.vue` 和 `ZiWeiPage.vue` 的导入路径。
    *   修正了 `components/ZiWeiPage.vue` 中对 `astrolabeStore` 的导入路径。

#### 重构的好处

1.  **更优的用户体验**: 用户无需离开首页即可完成信息输入，流程更顺畅。
2.  **健壮的状态管理**: 通过 Pinia 实现了命盘数据的跨页面、跨组件共享，彻底解决了因路由跳转导致的状态丢失问题，使应用状态管理更加可靠。
3.  **清晰的组件职责**: `ZiWeiForm.vue` 现在是一个纯粹的表单组件，而 `ZiWeiPage.vue` 是一个纯粹的展示组件，职责更加分明，易于维护。

## 2025.07.06

### 实现导航栏触发排盘抽屉功能

实现了点击顶部导航栏中的"排盘"按钮，可以直接弹出排盘信息输入抽屉的功能，优化了核心操作路径。

#### 实现过程

本次功能实现遵循了组件化和状态管理的最佳实践，通过创建一个全局状态中心来解耦两个原本不直接相关的组件：

1.  **创建全局状态管理 (Store)**:
    *   在 `src/stores/` 目录下创建了新的 `drawerStore.ts` 文件。
    *   使用 Vue 3 的 Composition API (`ref`) 在此文件中定义了一个全局、响应式的 `isDrawerOpen` 状态变量，并提供了 `openDrawer` 和 `closeDrawer` 两个方法来修改此状态。这使得抽屉的可见性状态可以在整个应用中被任何组件访问和控制。

2.  **改造表单抽屉 (`ZiWeiForm.vue`)**:
    *   移除了组件内部用于控制抽屉显示的本地 `drawer` 状态。
    *   从新建的 `drawerStore` 中导入 `useDrawerStore`，并使用其提供的 `isDrawerOpen` 状态来通过 `v-model` 控制 `<el-drawer>` 的显示。
    *   将表单提交成功后关闭抽屉的逻辑，从修改本地变量 `drawer.value = false`，改为调用从 store 中获取的 `closeDrawer()` 方法。

3.  **改造导航栏 (`NavBar.vue`)**:
    *   将导航栏中的"排盘"一项，从一个 `<router-link>` 路由链接，修改为一个普通的 `<span>` 元素，使其不再触发页面跳转。
    *   为这个 `<span>` 元素绑定了一个 `@click` 事件处理器。
    *   该事件处理器会调用从 `drawerStore` 中获取的 `openDrawer()` 方法，将全局状态 `isDrawerOpen` 设置为 `true`，从而命令 `ZiWeiForm.vue` 中的抽屉打开。

#### 实现的好处

1.  **组件解耦**: `NavBar.vue` 和 `ZiWeiForm.vue` 两个组件无需存在父子或兄弟关系，它们通过一个独立的全局 store 进行通信，降低了组件间的耦合度，使代码结构更清晰。
2.  **状态集中管理**: 将抽屉的"开关"状态提升为全局状态，使得这个状态的管理和变更更加明确和可预测，便于未来的维护和扩展。
3.  **提升用户体验**: 将核心的"排盘"功能入口直接置于顶层导航，用户无需进行页面跳转即可快速开始操作，路径更短，体验更流畅。

## 2025.06.30

### 最终修正：校准大限顺逆行与数组索引的逻辑

本次更新是对前一次修复的再次校准，彻底解决了大限"顺行"与"逆行"在程序中的逻辑与紫微斗数理论完全一致的问题。

#### 问题分析

尽管上一次修复已经意识到了"顺行/逆行"与数组索引增减之间的关系，但对"顺行"的具体方向判断仍然是错误的。根据用户提供的命例（阴女，年干为己），其大限本应顺时针运转，但程序却错误地使其逆时针运转。

根本原因在于，`correctedDecadalLifePalaceIndex` 计算属性中 `stepDirection` 的计算逻辑被错误地反转了。`isShunXing`（顺行）为 `true` 时，本应对应数组索引的增加（`+1`），但被错误地设置为了减少（`-1`）。

#### 解决方案

本次修复是决定性的，直接将 `stepDirection` 的计算逻辑拨乱反正：

1.  **反转步进方向**:
    *   在 `ZiWeiGrid.vue` 的 `correctedDecadalLifePalaceIndex` 计算属性中，将核心的计算公式从 `const stepDirection = isShunXing ? -1 : 1;`
    *   修正为：`const stepDirection = isShunXing ? 1 : -1;`

2.  **同步更新注释**:
    *   同时，更新了 `correctedDecadalPalaceNames` 中的代码注释，明确指出"顺行 (isShunXing) 在图表上是顺时针，对应宫位数组索引增加"，确保代码和注释的完全统一。

#### 修复的好处

1.  **完全精确**: 确保了阳男阴女的"顺行"和阴男阳女的"逆行"完全符合紫微斗数排盘规则，解决了所有关于大限方向的已知 bug。
2.  **逻辑终局**: 经过多次迭代，关于大限排布方向的核心算法现已稳定且正确，为后续功能的开发奠定了坚实的基础。
3.  **代码清晰**: 修正后的代码逻辑清晰直观，与紫微斗数的理论模型直接对应，降低了后续维护的难度。

## 2025.06.29

### 修正大限宫位顺逆行方向的根本性逻辑错误

修复了因对"顺行"与"宫位数组索引"对应关系理解错误而导致的大限宫位方向判断完全颠倒的问题。

#### 问题分析

在紫微斗数的排盘标准中，"顺行"指的是宫位从命宫到父母宫、福德宫的方向。然而，在项目的 `palaces` 数组中，地支是按照"子、丑、寅、卯..."的顺序（逆时针）排列的。这个底层结构导致了一个核心的逻辑矛盾：

-   **顺行（命 -> 父母）**：在图表上是"顺时针"，但在数组中，索引是从 `午` 到 `未`，实际上是 **增加** 的。
-   **逆行（命 -> 兄弟）**：在图表上是"逆时针"，但在数组中，索引是从 `午` 到 `巳`，实际上是 **减少** 的。

之前的代码错误地将"顺行"等同于数组索引的减少，导致所有大限的运动方向完全相反。

#### 解决方案

本次修复直击问题核心，在 `ZiWeiGrid.vue` 中对所有相关计算属性进行了根本性的逻辑修正：

1.  **修正方向判断变量**：
    -   将 `isClockwise` 变量更名为 `isShunXing` (顺行)，使其语义更符合紫微斗数术语。
    -   在 `correctedDecadalLifePalaceIndex` 中，将 `stepDirection` 的计算逻辑修正为：`isShunXing ? 1 : -1`。即顺行时索引+1，逆行时-1。

2.  **同步修正十二宫排布算法**：
    -   在 `correctedDecadalPalaceNames` 中，同步更新了其内部的旋转方向判断。
    -   现在，`distance` (距离) 和 `targetOriginalIndex` (目标索引) 的计算都遵循了 `isShunXing` 为真的情况下，索引增加的原则。

3.  **完善代码注释**：
    -   在代码中增加了明确的注释，阐明了"顺行"与"数组索引增加"之间的关键对应关系，以防止未来再次发生混淆。

#### 修复的好处

1.  **方向正确**：彻底解决了大限宫位运转方向颠倒的问题，确保了排盘结果的准确性。
2.  **逻辑严谨**：代码逻辑现在与紫微斗数的底层排盘原理完全一致，消除了因概念混淆而产生的根本性错误。
3.  **可维护性增强**：通过更精确的命名和更清晰的注释，使得这段核心且复杂的逻辑变得易于理解和维护。

## 2025.06.28

### 修复大限宫位索引的累积计算错误

修复了因算法错误导致大限宫位从第三步起就发生偏离的问题。

#### 问题分析

在 `ZiWeiGrid.vue` 组件中，负责计算大限命宫索引的计算属性 `correctedDecadalLifePalaceIndex` 存在一个严重的逻辑错误。它在计算宫位步长时，错误地将大限的序号（`selectedDecadeIndexValue`）与自身相乘，相当于进行了一次平方运算。这导致：
-   第一、二大限（序号为0和1）时，`0*0=0`, `1*1=1`，计算结果侥幸正确。
-   从第三大限（序号为2）开始，`2*2=4`（而非2），`3*3=9`（而非3），错误被急剧放大，导致大限命宫的位置完全错误，后续所有宫位排布也因此错乱。

#### 解决方案

本次修复直指问题核心，修正了错误的计算公式：

1.  **修正计算公式**：
    将 `correctedDecadalLifePalaceIndex` 中的算法 `(lifePalaceOriginalIndex + (selectedDecadeIndexValue * step) % 12 + 12) % 12` 修正为一个简单、正确的线性计算：`(lifePalaceOriginalIndex + totalStep + 12) % 12`。

2.  **明确步长计算**:
    -   `totalStep` 的计算逻辑被修正为 `selectedDecadeIndexValue * stepDirection`。
    -   `stepDirection` 根据命盘的阴阳、男女信息正确地判断为 `+1`（逆时针）或 `-1`（顺时针）。

#### 修复的好处

1.  **计算精确**: 彻底根除了累积性错误，确保所有大限的命宫位置都能被精确计算。
2.  **逻辑严谨**: 算法现在能正确反映大限宫位随时间线性、步进的规律，符合紫微斗数排盘规则。
3.  **可靠性提升**: 修复了这一底层计算错误后，所有依赖于大限命宫位置的功能（如宫位名称排布、高亮显示等）都恢复了正常。

## 2025.06.27

### 修复流年宫位排布并优化状态管理

本次更新彻底修复了流年十二宫名称的排布错误，并解决了一系列因此修复而引发的连锁性状态管理问题。

#### 问题分析

1.  **流年宫位算法错误**：与之前的大限问题类似，流年宫位的名称计算也错误地依赖了一个固定的"标准顺序"，而没有遵循当前命盘独一无二的物理布局。这导致了除"流年命宫"外，其他所有流年宫位名称都显示错误。
2.  **连锁状态管理问题**：在修复上述问题的过程中，对`ZiWeiGrid.vue`组件的状态变量`currentHoroscopeType`的修改引发了一系列连锁错误，包括"变量重复声明"和"无法为只读属性赋值"，暴露出该变量在状态管理上的设计缺陷。

#### 解决方案

本次修复采取了"标本兼治"的策略：

1.  **根治流年算法**：
    *   为流年宫位增加了`correctedYearlyPalaceNames`计算属性，它复用了之前已验证成功的、基于命盘自身物理结构进行宫位旋转的精确算法。
    *   根据紫微斗数规则，为该算法设定了固定的"顺时针"旋转方向。
    *   在UI上增加了"显示/隐藏流年宫位"的切换按钮，让用户可以自由查看。

2.  **重构状态管理**：
    *   **正本清源**：彻底重构了`currentHoroscopeType`变量。删除了之前所有对其进行手动赋值的不可靠逻辑。
    *   **改为计算属性**：将其转换为一个`computed`（计算属性），使其值能根据核心状态`currentHoroscope`的改变而自动、准确地推导出来。
    *   **修正逻辑**：优化了该计算属性的内部逻辑，确保它始终读取运限历史数组中最后一个（即最精确的）元素的类型。

#### 修复的好处

1.  **显示准确**：确保了流年十二宫的名称在任何命例下都能正确显示，与紫微斗数规则完全一致。
2.  **逻辑健壮**：通过将`currentHoroscopeType`改造为计算属性，消除了手动管理状态带来的不确定性和潜在bug，使组件的状态更新逻辑更加清晰、健壮和可预测。
3.  **代码优雅**：移除了冗余和错误的代码，使组件逻辑更加精炼。

## 2025.06.26

### 修复大限宫位排布算法

修复了因错误地假设十二宫有固定布局而导致的大限宫位名称计算错误，确保所有大限的宫位排布都严格遵循当前命盘独一无二的物理结构。

#### 问题分析

此前 `correctedDecadalPalaceNames` 计算属性的算法存在根本性缺陷。它基于一个"标准"的十二宫顺序（命、兄、夫、子...）去计算旋转后各宫位的名称。然而，在紫微斗数中，每个命盘的十二宫物理位置（即相对于寅宫的顺时针位置）都是不同的。这个错误的假设导致：

1.  **第一大限错误**：本应与本命盘完全重合的第一个大限，其宫位名称（除命宫外）都显示错误。
2.  **后续大限错误**：后续大限的旋转虽然发生了，但因为基础布局是错误的，所以旋转结果也是错误的。

#### 解决方案

重写了 `correctedDecadalPalaceNames` 的核心算法，使其不再依赖任何外部的、想当然的"标准顺序"，而是严格基于当前命盘自身的结构：

1.  **映射真实布局**: 新算法首先遍历当前命盘的 `palaces` 数组，创建一个从真实宫位名称到其物理位置索引的双向映射。这步操作捕获了当前命盘独一无二的物理结构。
2.  **计算相对位移**: 算法会计算出每个物理宫位（索引0-11）与当前"大限命宫"所在物理宫位的"距离"（`distance`）。
3.  **应用相对位移**: 最后，算法将这个"距离"应用到本命盘的真实布局上，从本命命宫开始，通过这个距离找到对应的本命宫位，从而确定当前物理宫位在大限中应有的正确名称。

#### 修复的好处

1.  **遵循命盘独特性**: 新算法尊重并利用了每个命盘的唯一结构，确保了计算的普适性和准确性。
2.  **第一大限正确**: 确保了第一个大限的十二宫位名称与本命盘完全对应，符合紫微斗数排盘规则。
3.  **后续大限正确**: 后续所有大限的宫位作为一个整体，在真实物理布局的基础上进行正确的顺/逆时针旋转。
4.  **逻辑严谨**: 彻底根除了因错误假设而导致的系列问题，使得大限排布的逻辑更加健壮、可靠。

## 2025.06.15

### 修复大限宫位名称显示错误

修复了在某些命例中大限十二宫位名称显示不正确的问题。

#### 问题分析

通过对多个命例进行测试，发现`ZiWeiGrid.vue`组件在显示大限宫位名称时，在某些情况下会与后端服务返回的数据不一致，导致显示错误。
问题根源在于，组件内部的排盘规则（阳男阴女顺行，阴男阳女逆行）未能完全覆盖所有命例。

#### 解决方案

为确保前端显示的一致性和准确性，对`ZiWeiGrid.vue`组件进行了以下修改：

1.  **添加独立计算逻辑**：
    在组件内部增加了`correctedDecadalLifePalaceIndex`和`correctedDecadalPalaceNames`两个计算属性，用于根据命盘基本信息和当前选择的大限，独立计算大限命宫的正确索引以及十二宫位的对应名称。

2.  **修正排列方向判断**：
    优化了对大限顺、逆行方向的判断逻辑，确保其在所有情况下都能准确应用紫微斗数的排盘规则。

3.  **更新显示函数**：
    修改了`getHoroscopeNames`函数，使其在显示大限宫位名称时，使用新计算出的正确数据，不再依赖可能出错的后端返回数据。

#### 修复效果

本次修复确保了大限宫位名称在前端的显示完全基于准确的排盘规则，解决了之前在特定命例中出现的显示不一致问题，提高了应用的可靠性和准确性。

## 2025.06.09

### 运限计算逻辑重构

将运限计算逻辑从`FunctionalAstrolabe`类移至专门的`HoroscopeCalculator`类，实现关注点分离和单一职责原则。

#### 更新内容

1. 创建了三个新的服务类：
   - `HoroscopeCalculator`：负责运限计算逻辑
   - `PalaceNameService`：负责宫位名称计算
   - `TimePeriodCalculator`：负责时间周期计算

2. 更新了`ZiWeiHoroscope.vue`文件中所有使用`astrolabe.horoscope()`方法的地方：
   - 添加了`HoroscopeCalculator`的导入
   - 在`selectDecade`函数中将`props.astrolabe.horoscope(targetDate)`替换为`HoroscopeCalculator.calculateHoroscope(props.astrolabe, targetDate)`
   - 在`selectYear`函数中将`props.astrolabe.horoscope(yearDate)`替换为`HoroscopeCalculator.calculateHoroscope(props.astrolabe, yearDate)`
   - 在`updateHoroscope`函数中将`props.astrolabe.horoscope(currentDateStr)`替换为`HoroscopeCalculator.calculateHoroscope(props.astrolabe, currentDateStr)`
   - 在`updateYearHoroscope`函数中将`props.astrolabe.horoscope(yearDate)`替换为`HoroscopeCalculator.calculateHoroscope(props.astrolabe, yearDate)`

3. 修改了`FunctionalAstrolabe.ts`文件中的`horoscope`方法，使其调用`HoroscopeCalculator.calculateHoroscope()`：
   ```typescript
   horoscope = (targetDate: string | Date = new Date(), timeIndexOfTarget?: number) =>
     HoroscopeCalculator.calculateHoroscope(this, targetDate, timeIndexOfTarget);
   ```

4. 从`palace.ts`文件中移除了`getPalaceNames`和`getHoroscope`函数，将它们分别移至`PalaceNameService`和`TimePeriodCalculator`类中。

#### 重构的好处

1. **关注点分离**：将运限计算逻辑从`FunctionalAstrolabe`类移至专门的`HoroscopeCalculator`类，使代码结构更清晰
2. **单一职责原则**：每个类只负责一个功能领域，`FunctionalAstrolabe`负责星盘基础数据，`HoroscopeCalculator`负责运限计算
3. **可维护性提高**：运限计算逻辑集中在一个类中，便于后续维护和扩展
4. **代码复用**：`HoroscopeCalculator`可以被其他组件直接使用，不需要通过`FunctionalAstrolabe`实例

## 2025.06.10

### 组件逻辑简化重构

将`ZiWeiHoroscope.vue`组件中的业务逻辑移至服务层和Composable中，实现UI与业务逻辑分离。

#### 更新内容

1. 创建了运限数据适配器服务：
   - `HoroscopeAdapter`：负责格式化运限数据，将iztro库的计算结果转换为应用所需的数据结构
   - 实现了缓存机制，避免重复计算相同的运限信息
   - 添加了错误处理，提高代码健壮性

2. 创建了状态管理Composable：
   - `useHoroscope`：封装运限数据状态管理，包括大限/流年选择、状态更新等逻辑
   - 使用Vue 3的Composition API，提供响应式状态管理

3. 新增类型定义：
   - `HoroscopeInfo`：运限信息数据结构
   - `HoroscopeHistoryItem`：运限历史记录项数据结构
   - `Decade`：大限数据结构

#### 重构的好处

1. **关注点分离**：UI组件仅负责渲染和事件处理，业务逻辑移至服务层和Composable
2. **代码复用**：Composable可在多个组件中复用，避免逻辑重复
3. **可测试性提高**：业务逻辑与UI分离，便于单元测试
4. **可维护性提升**：组件代码减少，职责更清晰
5. **性能优化**：实现缓存机制，避免重复计算

### 大限选择功能测试重构

完成了大限选择功能的重构，测试重构效果是否符合预期。

#### 更新内容

1. 重构了`ZiWeiHoroscope.vue`组件的`selectDecade`函数：
   - 使用`useHoroscope` composable中的`selectDecade`函数替换原有的复杂逻辑
   - 原有的逻辑包含约100行代码，重构后减少到10行左右
   - 保留对其他状态的重置，确保与原有功能一致

2. 创建了测试组件：
   - 新增`src/tests/HoroscopeTest.vue`用于测试重构后的功能
   - 提供命盘加载和运限选择结果展示
   - 验证重构后的组件功能是否正常

## 2025.06.11

### 完成流年和流月功能重构

继续重构ZiWeiHoroscope.vue组件，完成流年和流月选择功能的重构。

#### 更新内容

1. 修复类型定义：
   - 更新`HoroscopeHistoryItem`接口，使其更灵活兼容不同的使用场景
   - 添加`CustomHoroscopeInfo`接口，统一处理各种运限数据格式

2. 增强HoroscopeAdapter服务：
   - 添加`formatMonthInfo`方法，用于格式化流月数据
   - 完善错误处理和缓存机制
   - 确保返回的数据格式一致

3. 扩展useHoroscope composable：
   - 添加`selectMonth`方法，支持流月选择功能
   - 管理流月相关的状态
   - 提供统一的历史记录管理

4. 重构ZiWeiHoroscope.vue组件：
   - 重构`selectYear`函数，从100+行代码减少到约15行
   - 重构`selectMonth`函数，从80+行代码减少到约15行
   - 保持与原有功能一致，同时简化组件代码

#### 重构的好处

1. **代码量大幅减少**：流年和流月选择函数合计减少约150行代码
2. **业务逻辑集中管理**：所有运限选择逻辑统一由useHoroscope composable管理
3. **降低组件复杂度**：组件只关注UI渲染和用户交互
4. **提高可维护性**：业务逻辑变更只需修改composable和服务，不影响组件
5. **统一状态管理**：所有运限状态集中管理，避免状态不一致问题

#### 后续计划

1. **完成流日和流时功能重构**：
   - 继续重构剩余的流日和流时选择功能
   - 添加相应的适配器方法和composable功能

2. **添加单元测试**：
   - 为服务和composable添加单元测试
   - 确保重构后的功能与原有功能一致

3. **优化性能**：
   - 进一步优化缓存策略
   - 减少不必要的计算和渲染

## 2025.06.12

### 引入Pinia状态管理

使用Pinia替代Composition API进行状态管理，进一步优化数据流和组件通信。

#### 更新内容

1. 添加Pinia状态管理：
   - 创建`horoscopeStore.ts`，使用Pinia的Composition API风格
   - 将之前的useHoroscope composable逻辑迁移到store中
   - 添加更完善的状态管理，包括选中状态、历史记录等

2. 优化HoroscopeAdapter服务：
   - 完善缓存机制，减少不必要的计算
   - 提供更灵活的数据格式化方法
   - 统一错误处理逻辑

3. 修改ZiWeiHoroscope.vue组件：
   - 使用Pinia store替代之前的composable
   - 减少本地状态，使用store中的集中状态
   - 简化状态更新逻辑

4. 更新类型定义：
   - 扩展CustomHoroscopeInfo接口，支持更多的运限数据格式
   - 确保类型安全，减少运行时错误

#### 重构的好处

1. **全局状态管理**：Pinia提供更强大的状态管理能力，包括状态持久化、DevTools支持等
2. **更好的组件通信**：避免深层props和emit，简化组件间通信
3. **状态逻辑复用**：store中的逻辑可在多个组件中复用，提高代码一致性
4. **更好的可测试性**：Pinia store更容易进行单元测试
5. **状态变更追踪**：通过DevTools可以清晰追踪状态变更，便于调试
6. **可扩展性提升**：为后续添加更多功能（如流日、流时选择）提供了良好的基础

## 2025.06.13

### 添加Pinia持久化功能

为Pinia store添加持久化功能，保存用户的运限选择状态，提高用户体验。

#### 更新内容

1. 添加持久化插件：
   - 安装`pinia-plugin-persistedstate`插件
   - 在`main.js`中配置Pinia使用持久化插件
   - 为`horoscopeStore`添加持久化配置

2. 优化持久化策略：
   - 设置持久化key为`iztro-horoscope-state`
   - 使用localStorage作为存储介质
   - 自动保存所有状态

3. 添加状态恢复逻辑：
   - 在组件挂载时检查存储的状态
   - 根据存储的命盘ID判断是否需要恢复状态
   - 按照大限、流年、流月、流日、流时的顺序恢复之前的选择

4. 增强用户体验：
   - 添加状态恢复成功的提示信息
   - 记录最近查看的命盘ID，便于状态恢复

#### 持久化的好处

1. **会话连续性**：用户刷新页面或重新访问时可以恢复之前的选择状态
2. **减少重复操作**：用户不需要重新选择之前已经查看过的运限信息
3. **提高用户粘性**：改善用户体验，增加用户留存率
4. **状态可追溯**：持久化的状态可以用于数据分析和用户行为追踪
5. **减轻服务器负担**：本地存储减少了对服务器的请求次数

## 2025.06.14

### 修复流年计算逻辑

修复了大限和流年计算的问题，确保流年计算准确无误，特别是对于2002-1-20出生的女性命盘和2024-2-5出生的命例。

#### 更新内容

1. 修改HoroscopeAdapter.formatDecadalInfo方法：
   - 将大限年龄计算从使用中点年龄改为使用起始年龄
   - 统一大限起始年份计算公式为：出生年份 + 起运年龄 - 2
   - 修改代码：
     ```typescript
     // 修改前
     const midAge = Math.floor((decade.range[0] + decade.range[1]) / 2);
     const targetYear = birthYear + midAge;
     
     // 修改后
     const startAge = decade.range[0];
     const targetYear = birthYear + startAge - 2; // 统一计算公式
     ```
   - 确保大限对应的流年从大限的起始年龄开始计算，并考虑虚岁和起运年份

2. 修改虚岁计算逻辑：
   - 在formatYearInfo和formatMonthInfo方法中使用传统虚岁计算方式
   - 修改代码：
     ```typescript
     // 修改前（使用TimePeriodCalculator.calculateNominalAge方法）
     const age = calculateNominalAge(birthYear, year, birthMonth, birthDay, ...);
     
     // 修改后（使用传统虚岁计算）
     const age = year - birthYear + 1; // +1是因为出生即为1岁
     ```
   - 确保虚岁计算符合中国传统方式

3. 统一大限年份计算公式：
   - 经过多次测试和验证，确定紫微斗数中大限起始年份的统一计算公式为：
     ```
     大限起始年份 = 出生年份 + 起运年龄 - 2
     ```
   - 这个公式适用于所有出生年份和起运年龄的组合
   - 例如：
     - 2002年出生，土五局，5岁起运，第一个大限起始年份为2005年（2002+5-2=2005）
     - 2024年出生，火六局，6岁起运，第一个大限起始年份为2028年（2024+6-2=2028）
   - 公式中减2的原因：
     1. 虚岁比实岁大1岁（出生即为1岁）
     2. 大限起运是从下一年开始计算的

4. 修复流月数据处理问题：
   - 发现流月数据是对象而非数组，导致forEach方法调用失败
   - 添加类型检查和适当的数据处理：
     ```typescript
     // 修改前
     localYearData.value.monthly.forEach((month, idx) => {
       console.log(`${idx+1}月: ${month.heavenlyStem}${month.earthlyBranch}`);
     });
     
     // 修改后
     if (Array.isArray(localYearData.value.monthly)) {
       // 如果是数组，使用forEach
       localYearData.value.monthly.forEach((month, idx) => {
         console.log(`${idx+1}月: ${month.heavenlyStem}${month.earthlyBranch}`);
       });
     } else if (typeof localYearData.value.monthly === 'object') {
       // 如果是对象，使用Object.entries
       Object.entries(localYearData.value.monthly).forEach(([key, value]) => {
         if (typeof value === 'object' && value !== null) {
           console.log(`${key}月: ${value.heavenlyStem || ''}${value.earthlyBranch || ''}`);
         }
       });
     }
     ```
   - 确保能够正确处理不同格式的流月数据

5. 深入理解大限起运计算逻辑：
   - 大限起运计算在`palace.ts`的`getHoroscope`函数中实现
   - 大限起运规则：
     - 阳男阴女顺行，阴男阳女逆行，每十年过一宫限
     - 起运年龄从五行局数开始，每大限跨越10年
   - 大限年龄范围的计算公式：`[五行局数 + 10*i, 五行局数 + 10*i + 9]`
   - 我们的修改与原始代码逻辑保持一致，只是将计算过程简化为一个统一的公式

#### 修复的问题

针对不同出生年份的命例，修复了以下问题：
1. 对于2002-1-20出生的命例：
   - 土五局，5岁起运，第一个大限是5-14岁
   - 大限起始年份正确计算为2005年（2002+5-2=2005）
   - 辛丑流年正确显示为2005年

2. 对于2024-2-5出生的命例：
   - 火六局，6岁起运，第一个大限是6-15岁
   - 大限起始年份正确计算为2028年（2024+6-2=2028）
   - 虚岁计算符合传统方式，2025年的虚岁为2岁（2025-2024+1=2）

3. 流月数据处理逻辑更加健壮，可以处理不同格式的数据

#### 修复的好处

1. **计算准确性提高**：流年计算与紫微斗数理论和传统虚岁计算方式一致
2. **用户体验改善**：显示的流年信息更加准确，减少用户困惑
3. **虚岁计算符合传统**：使用中国传统虚岁计算方式（出生即为1岁）
4. **代码逻辑清晰**：统一使用一个简单的公式计算大限起始年份
5. **一致性增强**：所有运限计算逻辑保持一致，便于维护和理解
6. **错误处理改进**：增加了对不同数据格式的处理能力，提高了代码的健壮性
7. **通用性提高**：修复后的计算公式适用于所有出生年份和起运年龄的组合

## 2025.06.16

### 修复大限四化星显示问题

修复了点击大限时四化星（禄、权、科、忌）没有正确显示在对应宫位上的问题。

#### 更新内容

1. 修改`ZiWeiHoroscope.vue`中的`selectDecade`函数：
   - 在传递大限数据时添加原始选择的天干地支信息：
     ```typescript
     const safeDecadalInfo: HoroscopeInfo = {
       type: 'decadal',
       data: {
         // ... 其他属性 ...
         // 添加原始选择的大限天干地支信息
         originalHeavenlyStem: selectedDecade.heavenlyStem,
         originalEarthlyBranch: selectedDecade.earthlyBranch,
         // ... 其他属性 ...
       },
       // ... 其他属性 ...
     };
     ```

2. 修改`ZiWeiGrid.vue`中的`getHoroscopeMutagen`函数：
   - 使用原始选择的大限天干确定四化星，而不是计算结果中的天干：
     ```typescript
     // 获取大限天干 - 使用原始选择的大限天干，而不是计算结果中的天干
     let heavenlyStem = '';
     
     // 如果horoscopeItem.data中包含原始选择的大限天干，则使用它
     if (horoscopeItem.data.originalHeavenlyStem) {
       heavenlyStem = horoscopeItem.data.originalHeavenlyStem;
       console.log(`使用原始选择的大限天干: ${heavenlyStem}`);
     } else if (horoscopeItem.data.heavenlyStem) {
       // 否则使用计算结果中的天干
       heavenlyStem = horoscopeItem.data.heavenlyStem;
       console.log(`使用计算结果中的大限天干: ${heavenlyStem}`);
     }
     ```

3. 修改`ZiWeiGrid.vue`中的`getHoroscopeStars`函数：
   - 使用原始选择的大限地支确定流曜星位置，而不是计算结果中的地支：
     ```typescript
     // 获取原始选择的大限地支索引
     let selectedDecadeEarthlyBranch = '';
     if (horoscopeItem.data.originalEarthlyBranch) {
       selectedDecadeEarthlyBranch = horoscopeItem.data.originalEarthlyBranch;
       console.log(`使用原始选择的大限地支: ${selectedDecadeEarthlyBranch}`);
     } else if (horoscopeItem.data.earthlyBranch) {
       selectedDecadeEarthlyBranch = horoscopeItem.data.earthlyBranch;
       console.log(`使用计算结果中的大限地支: ${selectedDecadeEarthlyBranch}`);
     }
     
     // 获取选择的大限地支索引
     const selectedDecadeEarthlyBranchIndex = branches.indexOf(selectedDecadeEarthlyBranch);
     
     // 计算目标宫位索引
     let targetIndex = 0;
     if (isClockwise) {
       // 顺时针排列
       targetIndex = (earthBranchIndex + 12 - selectedDecadeEarthlyBranchIndex) % 12;
     } else {
       // 逆时针排列
       targetIndex = (selectedDecadeEarthlyBranchIndex + 12 - earthBranchIndex) % 12;
     }
     ```

4. 添加调试功能：
   - 在`ZiWeiGrid.vue`中添加`debugDecadalStarsCalculation`函数，用于打印大限四化星和流曜星的计算过程
   - 添加对原始选择的大限天干地支的打印：
     ```typescript
     // 打印原始选择的大限天干地支
     if (decadalData.data.originalHeavenlyStem && decadalData.data.originalEarthlyBranch) {
       console.log('原始选择的大限天干地支:', decadalData.data.originalHeavenlyStem, decadalData.data.originalEarthlyBranch);
       console.log('注意: 四化星将使用原始选择的大限天干');
     }
     ```

#### 修复的问题

1. 大限四化星显示问题：
   - 之前点击"己丑"大限时，后台使用的是"戊戌"大限的天干"戊"来确定四化星
   - 修复后使用实际选择的大限天干"己"来确定四化星，正确显示"武曲化禄、贪狼化权、天梁化科、文曲化忌"

2. 大限四化星显示问题：
   - 之前四化星的位置是根据计算出的"戊戌"大限确定的，而不是用户选择的"己丑"大限
   - 修复后使用实际选择的大限地支"丑"来确定流曜星位置，确保流曜星正确显示在对应宫位

#### 修复的好处

1. **用户体验改善**：点击大限时，四化星和流曜星能够正确显示在对应宫位
2. **计算准确性提高**：使用实际选择的大限天干地支进行计算，而不是固定年份计算出的天干地支
3. **代码健壮性增强**：添加了多层数据获取逻辑，即使原始数据缺失也能回退到计算结果
4. **调试能力提升**：添加了详细的日志输出，便于排查问题
5. **数据一致性保证**：确保UI显示的大限天干地支与实际计算使用的天干地支一致
6. **不影响其他功能**：修改只针对四化星和流曜星的计算，不影响大限运限计算逻辑

## 2025.06.17

### 修复第一个大限宫位名称显示

修复了第一个大限的十二宫位名称未能与本命盘宫位名称保持一致的问题，这是后续所有大限排布正确的基础。

#### 更新内容

1.  **增加大限序号判断**:
    -   在 `ZiWeiGrid.vue` 的 `handleHoroscopeUpdate` 函数中，添加了对 `selectedDecadeIndex` 的判断。
    -   当 `selectedDecadeIndex === 0` 时，认定为第一个大限。

2.  **直接复制本命宫位**:
    -   对于第一个大限，程序现在会遍历本命盘的 `palaces` 数组，并将其宫位名称直接赋给大限的宫位名称数组。
    -   此举确保了第一个大限的所有宫位名称（命宫、兄弟宫、夫妻宫等）与本命盘完全对应。

3.  **分离处理逻辑**:
    -   将第一个大限的处理逻辑与后续大限的动态计算逻辑用 `if/else` 完全分离开，避免了之前错误的算法被错误地应用到第一个大限上。

#### 修复的好处

1.  **遵循排盘规则**: 确保了第一个大限的排盘与紫微斗数"大限由本命命宫起"的规则一致。
2.  **奠定后续基础**: 正确设置第一个大限是后续大限按规律顺逆轮转的基础，为修复后续的运转方向问题铺平了道路。
3. **逻辑清晰**: `if (selectedDecadeIndex === 0)` 的结构使得代码意图更加明确，易于理解和维护。

### 修复大限宫位运转方向

修复了从第二个大限开始，宫位运转方向错误的问题，确保其严格遵循紫微斗数的排盘规则。

#### 更新内容

1.  **修正核心计算逻辑**：
    -   在 `ZiWeiGrid.vue` 的 `handleHoroscopeUpdate` 函数中，修正了判断大限顺/逆时针运转方向的核心逻辑。
    -   此前，程序中顺时针和逆时针对应的数组索引增减量是颠倒的，导致大限命宫的推移方向完全错误。

2.  **明确对应关系**：
    -   **顺时针 (阳男阴女)**：大限命宫从本命命宫 -> 父母宫 -> 福德宫...，现在正确对应 `palaces` 数组索引 **递减** (`-1`)。
    -   **逆时针 (阴男阳女)**：大限命宫从本命命宫 -> 兄弟宫 -> 夫妻宫...，现在正确对应 `palaces` 数组索引 **递增** (`+1`)。

3.  **更新代码注释**：
    -   同步修改了代码中的注释，使其与修正后的逻辑保持一致，提高了代码的可读性和可维护性。
    -   修改前：`const directionStep = isClockwise ? 1 : -1;`
    -   修改后：`const directionStep = isClockwise ? -1 : 1;`

#### 修复的好处

1.  **计算准确性**：确保了所有大限的宫位名称排布都严格符合紫微斗数理论，解决了从第二个大限开始宫位名称不正确的问题。
2.  **逻辑清晰**：代码逻辑与紫微斗数的顺逆行规则完全对应，便于后续理解和维护。
3. **用户体验提升**：用户在切换不同大限时，能够看到完全正确的宫位对应关系，增强了工具的专业性和可信度。

### 修复大限四化星重复显示及渲染时序错误

解决了在选择大限时，会错误地显示两套四化星（大限四化与本命四化），以及在页面初始化时因数据未准备好而导致的渲染错误。

#### 更新内容

1.  **重构 `getStarMutagenType` 函数逻辑**:
    -   **问题定位**: `getStarMutagenType` 函数在检查完大限四化后，没有立即停止，而是继续检查本命四化，导致了四化星的重复显示。
    -   **建立"运限优先"原则**:
        -   当有运限（如大限）被选中时，函数将 **只** 查找并返回当前运限的四化星，然后立即退出，不再理会本命四化。
        -   只有在 **没有** 任何运限被选中时，函数才会去查找并返回本命四化。

2.  **增加渲染时序的防御性编程**:
    -   **问题定位**: 页面初始化时出现 `TypeError: Cannot read properties of undefined (reading '0')` 的运行时错误。
    -   **原因分析**: 组件在渲染初期调用了 `getStarMutagenType` 函数，但此时 `props.astrolabe.mutagen` 属性尚未被完全计算好，值为 `undefined`。
    -   **添加安全校验**: 在读取 `mutagens` 数组之前，增加了一个 `if (mutagens)` 的存在性检查。如果 `mutagens` 不存在，函数会安全地返回 `null`，避免了程序因时序问题而崩溃。

#### 修复的好处

1.  **显示准确性**: 确保在任何时候都只显示一套正确的四化星（运限优先于本命），符合紫微斗数实际应用。
2.  **程序健壮性**: 增加了对 `undefined` 值的防御性编程，消除了因组件渲染时序问题导致的运行时错误，提升了应用的稳定性。
3. **逻辑严谨**: 明确了四化星的显示层级，使代码逻辑更清晰，更符合预期。

## 2025.06.18

### 完善大限流曜星显示功能

完成了对大限流曜星显示功能的扩展与统一，确保所有10颗重要的大限流曜星（运禄、运羊、运陀、运魁、运钺、运昌、运曲、运马、运鸾、运喜）都能在选择大限时正确显示。

#### 更新内容

1.  **扩展 `getHoroscopeStars` 函数**：
    -   在 `components/ZiWeiGrid.vue` 文件的 `getHoroscopeStars` 函数中，为 `horoscopeType === 'decadal'` 的情况增加了完整的流曜计算逻辑。

2.  **实现基于大限天干的流曜计算**：
    -   补充了 **大限文昌** 和 **大限文曲** 的计算逻辑，它们的位置由大限的天干决定。
    -   至此，所有由天干决定的核心流曜（禄、羊、陀、魁、钺、昌、曲）均已实现。

3.  **实现基于大限地支的流曜计算**：
    -   补充了 **大限天马**、**大限红鸾** 和 **大限天喜** 的计算逻辑，它们的位置由大限命宫的地支决定。

4.  **统一流曜命名规范**：
    -   根据您的要求，将所有通过此逻辑计算出的大限流曜星的名称前缀统一为"**运**"（例如，从"大限禄存"改为"运禄"），与您提供的示例数据格式保持一致。

#### 修复的好处

1.  **功能完整性**：补全了所有核心大限流曜的显示，使大限运势分析的信息更全面。
2.  **计算准确性**：确保了每颗流曜星都根据其对应的天干或地支规则，精确地显示在正确的宫位上。
3. **数据一致性**：统一了命名规范，使得从不同逻辑（天干、地支、随宫）产生的流曜星在UI上呈现的格式一致，便于理解。

## 2025.06.19

### 修复大限宫位旋转与排布系列问题

修复了从第二个大限开始，宫位旋转方向错误、宫位名称计算不准、排布布局错误以及UI高亮不正确等一系列关联问题。

#### 更新内容

1.  **修正旋转方向判断**:
    -   **问题**: 程序中对"阳男阴女"和"阴男阳女"顺逆时针的判断逻辑是颠倒的。
    -   **修复**: 彻底修正了 `handleHoroscopeUpdate` 函数中的布尔逻辑，使其严格遵循 "阳男阴女顺行，阴男阳女逆行" 的排盘规则。

2.  **标准化宫位名称匹配**:
    -   **问题**: 后端返回的本命盘宫位名称存在"命宫"和"父母"这样带"宫"与不带"宫"混用的情况，导致在寻找大限命宫落点宫位时(如查找"父母宫")匹配失败。
    -   **修复**: 在进行宫位查找前，对所有宫位名称(无论是标准名称还是来自后端数据)进行统一的标准化处理(`name.replace('宫', '')`)，从根本上解决了因名称不一致导致的查找失败问题。

3.  **重构宫位排布算法**:
    -   **问题**: 即使找到了正确的"大限命宫"落点，后续十一个宫位的排布逻辑也存在错误，未能正确复制本命盘的物理布局。
    -   **修复**: 重写了大限宫位的排布算法。新算法会先分析本命盘中十二宫的物理布局(即`palaces`数组中的相对索引关系)，然后确保大限的十二宫在旋转后，其相互之间的物理布局关系与本命盘完全一致，保证了结构的正确复制。

4.  **修正大限命宫高亮**:
    -   **问题**: 在切换到后续大限时，程序虽然内部计算出了正确的"大限命宫"新位置，但没有更新到负责UI高亮效果的`horoscopeLifePalaceIndex`变量。
    -   **修复**: 在计算出新的大限命宫索引后，增加了`horoscopeLifePalaceIndex.value = decadalLifePalaceIndex;` 这一步，确保UI正确高亮。

#### 修复的好处

1.  **计算准确**: 确保了从第二个大限起，所有大限的旋转方向、宫位名称、相对布局都完全正确，符合紫微斗数理论。
2.  **程序健壮性**: 通过名称标准化，增强了代码对上游数据微小差异的容错能力。
3. **UI反馈正确**: 用户在切换大限时，能从视觉上清晰地看到正确的"大限命宫"位置。
4. **逻辑清晰**: 将一系列关联问题逐一攻破，使得整个大限排布的逻辑现在变得清晰、准确且易于维护。

## 2025.06.20

### 对 ZiWeiGrid 组件进行架构重构

对过于臃肿的 `ZiWeiGrid.vue` 组件进行了架构重构，遵循关注点分离和单一职责原则，将其拆分为三个独立、清晰的部分。

#### 更新内容

1.  **抽离计算逻辑 (Composable)**：
    -   创建了新的 `src/composables/usePalaceCalculations.ts` 文件。
    -   将 `ZiWeiGrid.vue` 中所有纯粹的计算逻辑（如对宫计算、三方四正计算、星座计算、虚岁计算等）全部迁移到 `usePalaceCalculations` 这个 Composable 函数中。
    -   `ZiWeiGrid.vue` 现在通过调用这个钩子来获取所有计算数据，自身不再包含复杂的计算过程。

2.  **抽离展示逻辑 (纯展示组件)**：
    -   创建了新的 `src/components/ZiWeiPalaceDisplay.vue` 文件。
    -   这个组件只负责渲染单个宫位的UI，它接收处理好的数据作为 `props`，是一个纯粹的"哑"组件。
    -   所有与单个宫位相关的 HTML 模板和 CSS 样式都从 `ZiWeiGrid.vue` 移至此组件。

3.  **简化容器组件**:
    -   `ZiWeiGrid.vue` 现在作为一个"容器组件"。
    -   它的职责被大大简化，主要负责：
        -   管理状态（如当前选中的宫位）。
        -   调用 `usePalaceCalculations` Composable。
        -   通过 `v-for` 循环，将计算好的数据传递给 `ZiWeiPalaceDisplay` 组件进行渲染。
        -   处理用户交互事件。

#### 重构的好处

1.  **可维护性提升**: 每个部分职责单一，修改一个功能（如计算或显示）不会影响其他部分。
2.  **可复用性增强**: `usePalaceCalculations.ts` 的计算逻辑可以被任何其他组件复用，`ZiWeiPalaceDisplay.vue` 也可以在其他地方单独展示一个宫位。
3. **性能优化潜力**: `ZiWeiPalaceDisplay.vue` 作为一个纯展示组件，为将来使用 `v-memo` 等性能优化指令提供了可能。
4. **代码结构清晰**: 新的结构使得数据流（容器 -> 计算 -> 展示）一目了然，极大地改善了开发体验和可读性。

## 2025.06.21

### 修复流年命宫定位与宫位排布系列问题

修复了因对地支宫位图的错误假设以及对"占星新年"与"公历新年"界定不清而导致的流年命宫（太岁）定位错误、宫位名称排布不准确等一系列问题。

#### 更新内容

1.  **修正太岁定位逻辑**:
    -   **问题**: `HoroscopeAdapter` 中，程序使用了一个固定的标准地支顺序 `['子', '丑', '寅'...'亥']` 来查找流年地支（太岁）的索引。然而，每个命盘的十二宫地支排布顺序是独一无二的，这个错误的假设导致流年命宫定位出现偏差。
    -   **修复**: 彻底废除了固定的地支数组。新的逻辑直接在当前命盘实例 (`astrolabe.palaces`) 中进行查找，使用 `astrolabe.palaces.findIndex(p => p.earthlyBranch === yearlyEarthlyBranch)` 来获取太岁地支在该命盘中的**真实物理索引**，从根本上确保了定位的准确性。

2.  **修正新年界定日**:
    -   **问题**: 程序使用每年的1月1日作为基准日来计算流年数据。但在中国干支纪年中，新年通常由"立春"（约公历2月4日）决定。这导致在查询年初（如2006年1月1日）的数据时，底层库会返回上一个占星年（乙酉年）的数据，使得流年太岁"后退了一格"。
    -   **修复**: 将 `HoroscopeAdapter` 中所有用于计算大限和流年的基准日期从 `new Date(year, 0, 1)` (1月1日) 修改为 `new Date(year, 5, 15)` (6月15日)。这个日期处于一年的绝对中期，完全避开了新年界定的模糊区域，确保总能获取到目标年份的正确干支数据。

#### 修复的好处

1.  **定位精确**: 流年命宫现在能够完全准确地落在其地支所对应的本命宫位上，解决了"差一步"或"多一步"的现象。
2. **遵循命盘独特性**: 新的定位逻辑不再依赖任何想当然的顺序，而是严格尊重每个命盘自身的实际布局，大大提高了算法的健壮性和普适性。
3. **遵循占星规则**: 解决了因公历和农历（干支历）新年起点不同而导致的计算错误，使程序的计算结果更符合占星学的实际应用规则。
4. **逻辑严谨**: 从根本上消除了两个主要的逻辑漏洞，使得整个流年运限的计算和显示变得更加可靠和可信。

## 2025.06.22

### 流年流曜命名规范统一与功能补全

#### 新增内容

1. **流年流曜命名统一**：
   - 将流年相关的流曜星名称全部统一为"流魁、流钺、流昌、流曲、流禄、流羊、流陀、流马、流鸾、流喜"。
   - 其中"流魁、流钺、流昌、流曲、流禄、流羊、流陀"分别对应原有的天魁、天钺、昌、曲、禄存、擎羊、陀罗。
   - "流马、流鸾、流喜"则参考大限流曜的规则，基于流年命宫地支动态计算。

2. **完善流年流曜显示逻辑**：
   - 在`ZiWeiGrid.vue`的`getHoroscopeStars`函数中，补全了所有流年流曜的计算与显示。
   - 具体包括：
     - 流魁、流钺：根据流年天干查表定位。
     - 流昌、流曲：根据流年天干查表定位。
     - 流禄、流羊、流陀：根据流年天干查表定位。
     - 流马、流鸾、流喜：根据流年命宫地支推算。
   - 保证点击流年时，命盘各宫位能正确显示所有核心流年流曜。

3. **保留太岁十二神**：
   - 继续在流年宫位显示太岁、晦气、丧门、贯索、官符、小耗、大耗、龙德、白虎、天德、吊客、病符等十二神。

#### 实现细节

- 统一所有流年流曜星的名称前缀为"流"，与大限"运"系列区分。
- 采用与大限流曜一致的查表与推算方式，保证显示规则的专业性和一致性。
- 代码位置：`components/ZiWeiGrid.vue` 的 `getHoroscopeStars` 函数。

#### 修复的好处

1.  **专业性提升**：所有流年流曜星名称与专业紫微斗数术语完全一致。
2.  **用户体验优化**：用户点击流年即可一目了然地看到所有核心流曜星，且命名规范统一。
3. **功能完整**：补全了流年流曜的所有核心星曜，信息展示更全面。
4. **代码一致性**：大限与流年流曜的实现方式保持一致，便于维护和扩展。

## 2025.06.23

### 运限宫位与流曜样式重构

对 `ZiWeiPalaceDisplay.vue` 组件进行了全面的样式调整，以更清晰、更有层次感的方式展示大限和流年的相关信息。

#### 更新内容

1.  **宫位名称层级与样式调整**:
    *   **重新定义显示层级**: 确立了新的宫位名称显示优先级：**流年 > 大限 > 本命**。
    *   **引入颜色编码**:
        *   流年宫位名称（如"流年父母"）设置为 **蓝色**。
        *   大限宫位名称（如"大限福德"）设置为 **绿色**。
        *   本命宫位名称保持原有的 **红色**。
    *   **优化模板结构**: 在 `ZiWeiPalaceDisplay.vue` 中，通过 `v-if` 指令和独立的 `div` 容器，严格控制了上述层级的显示逻辑。

2.  **运限流曜布局与样式调整**:
    *   **统一移动至右上角**: 将大限流曜（运曜）和流年流曜（流曜）都从左下角移到了宫位的右上角区域，使其更加醒目且不与底部信息重叠。
    *   **实现并排布局**: 采用了 Flexbox 布局，将流年流曜放置在大限流曜的左侧。
    *   **统一竖向文字排列**: 将大限和流年流曜的文字全部设置为竖向排列，使布局更紧凑美观。
    *   **颜色编码**:
        *   流年流曜（如"流羊"、"流陀"）的背景色设置为 **蓝色**。
        *   大限流曜（如"运羊"、"运陀"）的背景色设置为 **绿色**。

3.  **修复数据传递问题**:
    *   在 `ZiWeiGrid.vue` 的 `getHoroscopeStars` 函数中，将传递给子组件的星曜对象的属性名从 `type` 修正为 `horoscopeType`，解决了子组件无法正确识别大限流曜类型的问题，确保了新样式的正确应用。

#### 重构的好处

1.  **视觉清晰度提升**: 通过颜色和位置区分，用户可以瞬间辨别出本命、大限、流年三个不同层级的信息。
2.  **信息密度与美观度**: 将流曜星移至右上角并采用竖排方式，既节省了空间，又使命盘布局显得更加专业、整洁。
3. **代码健壮性**: 通过分离不同类型的流曜数据和样式，使得 `ZiWeiPalaceDisplay.vue` 的逻辑更加清晰，便于未来对特定运限类型进行独立修改。

## 2025.06.24

### 修复流年神煞数据显示

修复了在选择"流年"后，其专属的"将前十二神"和"岁前十二神"未能显示在命盘上的问题。

#### 更新内容

1.  **定位问题根源**:
    *   通过日志分析发现，虽然 `HoroscopeCalculator` 已经正确计算出了包含这两套神煞的 `yearlyDecStar` 数据，但在数据传递的中转站 `HoroscopeAdapter` 服务中，这个关键属性被遗漏了。

2.  **修正数据适配器**:
    *   修改了 `src/services/HoroscopeAdapter.ts` 文件中的 `formatYearInfo` 函数。
    *   在函数内部，将 `horoscopeInfo.yearly.yearlyDecStar` 数据正确地添加到了返回给前端的 `result` 对象中。

3.  **打通数据链路**:
    *   此修改修复了从数据计算层到UI展示层的数据流中断问题，确保了神煞数据能够被 `ZiWeiGrid.vue` 接收并最终由 `ZiWeiPalaceDisplay.vue` 渲染。

#### 修复的好处

1.  **功能完整性**: 补全了流年运势分析所需的重要神煞信息，使其功能更加完整。
2.  **数据流完整性**: 确保了所有后端计算出的数据都能无遗漏地传递到前端，提高了程序的可靠性。
3. **用户体验改善**: 用户现在可以查看到更丰富的流年信息，有助于进行更精细的命理分析。

## 2025.06.25

### 宫位逻辑重构：创建 PalaceNameService

为了进一步贯彻"关注点分离"和"单一职责"的设计原则，我们对项目中所有与"宫位"相关的计算和分析逻辑进行了重构，将其统一收归到一个全新的服务类 `PalaceNameService` 中。

#### 更新内容

1.  **创建 `PalaceNameService.ts`**:
    *   在 `src/astro/` 目录下新建了 `PalaceNameService.ts` 文件。
    *   该服务类现在是处理所有宫位逻辑（获取、分析、名称计算）的唯一入口点。

2.  **迁移并整合核心逻辑**:
    *   **从 `analyzer.ts` 迁移**: 将之前分散在 `analyzer.ts` 中的 `getPalace` (获取单个宫位) 和 `getSurroundedPalaces` (获取三方四正) 函数，完整地迁移到了 `PalaceNameService` 中，并转为类的静态方法。
    *   **从 `HoroscopeCalculator.ts` 整合**: 将运限计算器中的宫位名称排布逻辑也一并移入，并重构为一个更通用、更强大的 `getHoroscopePalaceNames(startIndex, isClockwise)` 方法。

3.  **更新调用链路**:
    *   重构了 `FunctionalAstrolabe.ts`，使其 `palace()` 和 `surroundedPalaces()` 方法直接调用 `PalaceNameService` 的相应方法。
    *   重构了 `HoroscopeCalculator.ts`，使其在计算大限、小限、流年、流月等所有运限的宫位名称时，统一调用 `PalaceNameService.getHoroscopePalaceNames()`。

4.  **清理冗余代码**:
    *   彻底删除了 `analyzer.ts` 和 `PalaceNameService.ts` 中已经被迁移或废弃的旧函数及导出，保持了代码库的整洁。

#### 重构的好处

1.  **结构清晰**: 所有与宫位相关的操作都有了单一、明确的出处，极大地提升了代码的可读性和项目结构清晰度。
2.  **高内聚**: `PalaceNameService` 内部的函数紧密相关，都围绕"宫位"这一核心概念。
3.  **可维护性增强**: 当需要修改宫位的计算规则时，我们只需要在 `PalaceNameService` 一个地方修改，而无需在多个文件中寻找相关代码。
4.  **消除潜在风险**: 清理了旧的、分散的函数，减少了未来因误用旧代码而产生 bug 的风险。

### 服务类调用统一

解决了因重构导致部分文件仍在使用旧的、独立的函数调用方式而引发的运行时错误。

#### 更新内容

1.  **统一 `TimePeriodCalculator` 调用**:
    *   在 `src/astro/astro.ts` 和 `src/__tests__/astro/palace.test.ts` 中，将对大限/小限的计算调用方式从独立的 `getHoroscope()` 函数，统一为 `TimePeriodCalculator.getHoroscope()` 的静态方法调用。
    *   同时，为 `Astrolabe` 核心类型增加了 `decadals` 和 `ages` 属性，以使其能够承载运限数据。

2.  **统一 `PalaceNameService` 调用**:
    *   在 `src/astro/astro.ts` 中，将对宫位名称的获取方式从独立的 `getPalaceNames()` 函数，统一为 `PalaceNameService.getPalaceNames()` 的静态方法调用。

3.  **清理废弃的导出**:
    *   移除了 `TimePeriodCalculator.ts` 和 `PalaceNameService.ts` 文件末尾所有用于向后兼容的独立函数导出语句。
    *   此举虽然导致了对 `palace.ts` 的清理遇到一些困难，但因所有调用点均已更新，从根本上解决了运行时错误。

#### 修复的好处

1.  **调用方式统一**: 项目中所有对核心计算逻辑的调用，现在都通过标准的服务类（`ClassName.method()`)进行，增强了代码的一致性和可预测性。
2.  **消除运行时错误**: 彻底解决了 `does not provide an export named 'getPalaceNames'` 的问题。
3. **完成重构闭环**: 将所有散落的调用点全部更新，完成了本次"分离运算逻辑层"重构的最后一步。

## 2025.07.01

### 流月命宫规则重构与实现

本次更新对流月命宫（流月十二宫）推算与排布规则进行了彻底重构，确保其与紫微斗数理论及实际命例完全一致，并与流年命宫实现高度联动。

#### 规则说明

1. **正月命宫定位**：
    - 流月命宫的起点（正月命宫）不再采用传统的"寅宫为正月"或"命宫为正月"定法。
    - 新规则：以流年命宫（即当年太岁所在宫位）为基准，查找该宫位在命盘中的"人元宫"（即寅宫所对应的人元宫）。
    - 正月命宫 = 流年命宫所对应的人元宫。

2. **顺序推演**：
    - 正月命宫确定后，流月十二宫依次顺时针（固定方向）排列。
    - 二月命宫为正月命宫的下一个宫位，三月为再下一个，以此类推，直至十二月。
    - 排布顺序与男女、阴阳属性无关，始终顺时针。

3. **男女阴阳与顺逆无关**：
    - 与大限、流年等运限不同，流月命宫的推演不再区分男女、阴阳属性，全部采用顺时针排列。
    - 彻底消除因性别、阴阳导致的顺逆混淆。

4. **与流年联动**：
    - 流月命宫的正月起点，始终以当前所选流年命宫为基准。
    - 切换流年时，流月命宫自动重新定位。
    - 确保流月与流年运势分析的高度一致性。

#### 实现细节

- 相关计算逻辑已全部迁移至 `ZiWeiGrid.vue` 及其调用的服务层，采用全新算法实现。
- UI 层支持流月命宫的高亮与名称展示，正月起点与顺序推演一目了然。
- 代码注释中已详细标明新规则的理论依据与实现方式，便于后续维护。

#### 优化效果

1. **理论严谨**：完全符合紫微斗数流月排盘的最新理论与实务操作。
2. **用户体验提升**：用户切换流年后，流月命宫自动联动，排布直观清晰。
3. **消除歧义**：统一顺序、消除顺逆与性别歧义，极大提升专业性与易用性。
4. **维护便利**：所有流月相关逻辑集中、注释完善，便于后续扩展与优化。

## 2025.07.02

### 统一并修复运限（大限、流年、流月）宫位名称显示逻辑

本次更新对 `ZiWeiGrid.vue` 组件内所有运限（大限、流年、流月）的宫位名称显示逻辑进行了全面的审查和修复，统一了计算口径，解决了因算法不一致和索引错用导致的一系列显示错误。

#### 问题分析

1.  **流月显示错误**: 最初的问题是，选择"流月"时会显示全部十二宫的名称。这是因为后端的 `PalaceNameService` 未对流月做特殊处理，总是返回十二个宫位名。
2.  **大限与流年显示错误**: 在修复流月问题的过程中，引入了新的 Bug。`getHoroscopeNames` 函数未能正确使用已经修复好的 `correctedDecadalPalaceNames` 和 `correctedYearlyPalaceNames` 计算属性，而是沿用了一套陈旧且不正确的排布算法。此外，它还错误地使用了 `displayIndex` (显示索引) 而非 `palaceIndex` (物理索引) 来查询宫位名称，导致了错误的对应关系。
3.  **流年算法不一致**: `correctedYearlyPalaceNames` 的算法与 `correctedDecadalPalaceNames` 的精确算法不一致，依赖于一个固定的"标准顺序"，导致其计算结果不准确。

#### 解决方案

本次修复采取了"正本清源、统一标准"的策略：

1.  **修正流月数据源头**:
    *   修改了 `PalaceNameService.getHoroscopePalaceNames`，为其增加了 `type` 参数。当 `type` 为 `'monthly'` 时，函数返回一个空数组，从根源上阻止了多余的宫位名称生成。
    *   同步更新了 `HoroscopeCalculator.ts`，确保在调用时传递正确的运限类型。

2.  **统一流年算法**:
    *   重写了 `correctedYearlyPalaceNames` 计算属性，使其完全复用 `correctedDecadalPalaceNames` 中基于命盘自身物理结构进行精确旋转的健壮算法，确保了流年与大限排布逻辑的一致性和准确性。

3.  **重构核心显示函数 `getHoroscopeNames`**:
    *   彻底废除了其内部陈旧、错误的排布逻辑。
    *   新函数现在直接、且唯一地从 `correctedDecadalPalaceNames` 和 `correctedYearlyPalaceNames` 计算属性中获取数据。
    *   修正了索引错误，所有查询均使用正确的 `palaceIndex` (物理索引)，确保宫位与其名称一一对应。
    *   为大限、流年、流月的命宫增加了"大限命宫"、"流年命宫"、"流月命宫"的专属名称显示逻辑。

#### 修复的好处

1.  **逻辑统一**: 所有运限的宫位名称计算和显示都遵循同一套经过验证的精确算法，消除了潜在的逻辑冲突。
2.  **显示精确**: 无论是大限、流年还是流月，其十二宫的名称都能在任何命例下正确、清晰地显示。
3.  **代码健壮**: 通过重构和简化，`ZiWeiGrid.vue` 中的状态推导过程更加清晰，减少了因数据流混乱导致的错误，提升了组件的整体可维护性。

## 2025.07.03

### 区分大限与流年四化星样式

实现了大限四化与流年四化的颜色区分功能，并修复了其数据传递链路，确保用户能清晰地辨别不同层级运限的影响。

#### 更新内容

1.  **修改 `getStarMutagenType` 函数 (`ZiWeiGrid.vue`)**:
    *   **问题**: 该函数原先只能返回一个四化类型（如"禄"），无法区分其来源是生年、大限还是流年。
    *   **修复**: 重构了该函数，使其返回一个包含 `{ mutagen, horoscopeType }` 的对象。`horoscopeType` 明确标识了四化星的来源 (`native`, `decadal`, 或 `yearly`)。
    *   **优化查找顺序**: 确立了 **流年 > 大限 > 生年** 的优先级。函数会优先查找并返回最具体运限的四化，找到后立即停止，避免了之前可能发生的重复显示问题。

2.  **更新 `ZiWeiPalaceDisplay.vue` 组件**:
    *   **动态CSS类**: 修改了组件模板，现在会根据 `getStarMutagenType` 返回的 `horoscopeType` 值为四化角标动态添加 `.decadal` 或 `.yearly` 的CSS类。
    *   **新增CSS样式**: 添加了新的CSS规则，将大限和流年四化角标的背景色设置为用户指定的颜色，同时保留了生年四化原有的多彩样式：
        *   `.sihua-badge.decadal`: 背景色设置为 `rgb(38, 166, 38)` (绿色)。
        *   `.sihua-badge.yearly`: 背景色设置为 `rgb(36, 138, 221)` (蓝色)。

3.  **修复数据适配器 (`HoroscopeAdapter.ts`)**:
    *   **问题定位**: 经过调试发现，尽管 `HoroscopeCalculator` 计算出了大限和流年的四化数据 (`mutagen`)，但在 `HoroscopeAdapter` 的 `formatDecadalInfo` 和 `formatYearInfo` 函数中，这些数据被遗漏，没有被添加到返回给前端的对象里。
    *   **修复**: 在这两个函数中，将 `mutagen` 数据从完整的计算结果 `horoscopeInfo` 中提取出来，并添加到了返回的 `data` 对象中，打通了从计算到显示的数据链路。

#### 修复的好处

1.  **视觉区分清晰**: 用户现在可以通过直观的颜色（绿色/蓝色）轻松辨别出当前宫位受大限还是流年四化的影响，极大地提升了图表的可读性。
2.  **信息层级明确**: 不同的颜色代表了不同时间尺度的影响，帮助用户在分析时能够主次分明。
3.  **数据流完整可靠**: 从根本上修复了四化数据在传递过程中的丢失问题，确保了前端显示的准确性和计算结果的一致性。
4.  **逻辑健壮**: 优化的查找逻辑不仅解决了显示问题，也使代码更加严谨，避免了潜在的显示冲突。

## 2025.07.04

### 修正运限四化星的计算源头错误

修复了因底层依赖库返回错误数据而导致的运限（大限、流年）四化星计算不准确的问题，特别是针对"癸"天干的四化。

#### 更新内容

1.  **创建可靠的四化计算源**:
    *   **问题定位**: 经用户反馈和日志分析，发现程序在处理"癸"天干的大限时，显示的四化星是错误的。其根源在于，底层核心库根据日期计算出的四化数据本身存在偏差。
    *   **解决方案**: 为了从根本上保证准确性，我们在 `src/astro/HoroscopeCalculator.ts` 中新增了一个名为 `getAccurateMutagens` 的静态方法。
    *   **内置精确映射**: 该方法内部包含了一个完整且经过验证的"天干-四化星"映射表（从甲到癸），作为项目内部唯一可靠的四化数据来源。

2.  **修正数据适配器 (`HoroscopeAdapter.ts`)**:
    *   **切换数据源**: 修改了 `formatDecadalInfo` 和 `formatYearInfo` 这两个核心函数。
    *   **绕过错误数据**: 在生成返回给前端的运限数据时，程序不再采用底层库计算出的 `mutagen` 属性。
    *   **调用精确方法**: 转而调用我们自己创建的 `HoroscopeCalculator.getAccurateMutagens()` 方法，并传入当前运限（大限或流年）正确的天干，从而确保获取到的一定是正确的四化星数组。

#### 修复的好处

1.  **计算绝对准确**: 彻底解决了所有因上游依赖库计算错误而导致的四化星显示问题，保证了排盘结果的专业性和准确性。
2.  **逻辑内聚可靠**: 将四化星的计算逻辑收归项目内部，不再受外部依赖不确定性的影响，使得程序逻辑更加健壮、可控。
3.  **问题根治**: 此次修复并非简单的打补丁，而是从数据源头进行了替换，根治了所有同类型的潜在问题。

## 2025.07.05

### 修复流年神煞数据显示丢失问题

修复了在选择"流年"运限后，其专属的"将前十二神"和"岁前十二神"未能正确显示在命盘上的问题。

#### 更新内容

1.  **定位问题根源**:
    *   **现象**: 根据日志分析，命盘在初始化时能够正确加载并显示本命宫的"将前"和"岁前"神煞，证明基础数据是完整的。然而，一旦用户选择了一个具体的"流年"，这些神煞信息便会从界面上消失。
    *   **原因分析**: 问题出在数据从计算层到UI展示层传递过程中的一个环节。`HoroscopeAdapter.ts` 服务的 `formatYearInfo` 函数在格式化流年数据时，尝试从一个错误的路径 (`horoscopeInfo.yearly.jiangqian12`) 去获取神煞数据，而实际上这些数据被封装在 `horoscopeInfo.yearly.yearlyDecStar` 这个对象中。这个错误的路径导致了数据提取失败。

2.  **修正数据适配器 (`HoroscopeAdapter.ts`)**:
    *   **打通数据链路**: 修改了 `formatYearInfo` 函数的实现。
    *   不再尝试单独提取 `jiangqian12` 和 `suiqian12`，而是将 `horoscopeInfo.yearly.yearlyDecStar` 整个对象完整地传递给前端。
    *   此举确保了 `ZiWeiGrid.vue` 及其子组件能够接收到它们所期望的、包含完整神煞数据的对象结构。

#### 修复的好处

1.  **功能完整性**: 恢复了流年运势分析所需的重要神煞信息，使用户能够进行更全面的命理分析。
2.  **数据流完整性**: 确保了所有由后端计算出的关键数据都能无遗漏地传递到前端，提高了程序的可靠性和健壮性。
3.  **用户体验改善**: 用户在切换到流年时，能够看到一个包含完整信息的命盘，符合专业预期。

## 2025.07.08

### 修复 ZiWeiPage 无法直接触发排盘抽屉的问题

修复了在无命盘数据的紫微斗数结果页 (`/ziwei`) 时，点击顶部导航栏的"排盘"按钮无法像在首页一样直接弹出抽屉表单的问题。

#### 问题分析

1.  **用户流程中断**：当用户直接访问 `/ziwei` 页面但没有命盘数据时，系统会提示用户去首页输入。此时用户点击导航栏的"排盘"按钮，期望能立即输入信息，但抽屉并未出现，因为该页面组件树中缺少表单抽屉实例。
2.  **组件缺失**: `ZiWeiPage.vue` 组件中并未包含 `<ZiWeiForm />` 子组件。尽管导航栏的"排盘"按钮正确地通过 `drawerStore` 将全局的 `isDrawerOpen` 状态设为了 `true`，但由于页面上没有监听这个状态的抽屉组件，因此没有任何响应。

#### 解决方案

本次修复遵循了与 `HomePage.vue` 完全一致的设计模式，将表单抽屉添加到了结果页面中：

1.  **引入表单组件**: 在 `components/ZiWeiPage.vue` 的 `<script setup>` 部分，导入了 `ZiWeiForm.vue` 组件。
2.  **添加组件到模板**: 在 `ZiWeiPage.vue` 的模板中，直接添加了 `<ZiWeiForm />` 标签。

由于 `ZiWeiForm` 自身已经通过 `drawerStore` 实现了对全局状态的监听，因此只需在页面中简单地实例化该组件，即可使其响应导航栏的打开指令。

### 批量创建星曜详情JSON文件

为了方便用户编辑和管理每颗星耀的详细信息，我们执行了一项批量创建数据文件的任务。此过程旨在为所有核心星曜（主星、辅星、杂曜）在 `src/data/star-info/` 目录下生成对应的JSON文件模板。

#### 实现过程与挑战

1.  **数据源采集**:
    *   首先，通过读取 `src/star/` 目录下的 `majorStar.ts`, `minorStar.ts`, `adjectiveStar.ts` 等源文件，我们完整地提取了所有需要创建文件的星曜的唯一标识符（Key）。

2.  **初次尝试 (PowerShell)**:
    *   最初的方案是使用 PowerShell 脚本在用户终端中直接创建文件。
    *   然而，此方案遇到了两个障碍：一是多行脚本与终端工具的兼容性问题；二是PowerShell的字符串格式化功能与JSON的 `{}` 语法发生冲突，导致执行失败。

3.  **切换方案 (Node.js)**:
    *   为了彻底解决跨平台和语法兼容性问题，我们转向了一个更健壮的方案：动态创建一个临时的Node.js脚本 (`_create_star_files.js`) 来执行文件创建任务。

4.  **解决模块化冲突**:
    *   执行Node.js脚本时，遇到了一个新的问题：项目本身配置为ESM模块（`"type": "module"`），而我们编写的脚本使用了传统的CommonJS模块（`require`语法），导致`ReferenceError: require is not defined`的错误。
    *   **解决方案**: 根据Node.js的错误提示，我们将脚本的扩展名从 `.js` 修改为 `.cjs` (使用Windows的`ren`命令，而非跨平台的`mv`)。这个简单的修改告知Node.js将此文件作为CommonJS模块处理，从而解决了冲突。

5.  **成功执行与清理**:
    *   重命名后的脚本 (`_create_star_files.cjs`) 得以成功执行，一次性在目标目录下生成了所有需要的JSON文件。
    *   任务完成后，临时的 `.cjs` 脚本文件被自动删除，保持了项目根目录的整洁。

#### 最终成果

通过这个略带波折但最终成功的自动化流程，我们为超过60颗星曜创建了标准化的数据模板文件，极大地便利了后续内容的填充工作，并验证了一套可靠的、跨平台的自动化脚本执行方案。

# 问题解决记录

## 问题描述
在开发过程中遇到了以下问题：
1. 模板错误：缺少 `v-if` 条件
2. `iztro` 库版本过旧
3. 星耀信息加载问题

## 解决过程

### 1. 模板错误修复
在 `ZiWeiHoroscope.vue` 文件中发现缺少 `v-if` 条件的问题。通过添加 loading 块和 `v-else` 条件来修复模板结构。

### 2. 依赖更新
- 检查 `package.json` 中的 `iztro` 库版本
- 尝试更新 `iztro` 库到最新版本
- 执行 `npm install` 确认所有包都已更新到最新版本

### 3. 星耀信息加载问题
- 检查 `starInfo.ts` 文件中的键值对
- 修复缺失的键值问题
- 确保星耀信息能够正确加载

## 解决方案总结
1. 通过添加适当的条件渲染修复了模板错误
2. 更新了项目依赖到最新版本
3. 修复了星耀信息的数据结构问题

## 经验教训
1. 在开发过程中要注意模板结构的完整性
2. 定期检查和更新项目依赖
3. 确保数据结构的一致性，避免缺失键值

## 后续建议
1. 建立定期依赖更新机制
2. 添加更完善的错误处理机制
3. 考虑添加单元测试以确保功能稳定性